<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>听听代码敲敲歌</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://loewenw.github.io/"/>
  <updated>2017-12-06T13:30:24.330Z</updated>
  <id>http://loewenw.github.io/</id>
  
  <author>
    <name>Loe Wen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>http中的keep-alive</title>
    <link href="http://loewenw.github.io/2017/11/11/20171111/"/>
    <id>http://loewenw.github.io/2017/11/11/20171111/</id>
    <published>2017-11-11T10:11:29.000Z</published>
    <updated>2017-12-06T13:30:24.330Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、什么是Keep-Alive模式？"><a href="#1、什么是Keep-Alive模式？" class="headerlink" title="1、什么是Keep-Alive模式？"></a>1、什么是Keep-Alive模式？</h2><p>我们知道HTTP协议采用“请求-应答”模式，当使用普通模式，即非KeepAlive模式时，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接（HTTP协议为无连接的协议）；当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。</p><p>http 1.0中默认是关闭的，需要在http头加入”Connection: Keep-Alive”，才能启用Keep-Alive；http 1.1中默认启用Keep-Alive，如果加入”Connection: close “，才关闭。目前大部分浏览器都是用http1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep-Alive连接就看服务器设置情况。</p><h2 id="2、启用Keep-Alive的优点"><a href="#2、启用Keep-Alive的优点" class="headerlink" title="2、启用Keep-Alive的优点"></a>2、启用Keep-Alive的优点</h2><p>从上面的分析来看，启用Keep-Alive模式肯定更高效，性能更高。因为避免了建立/释放连接的开销。下面是RFC 2616上的总结：<br>a. By opening and closing fewer TCP connections, CPU time is saved in routers and hosts (clients, servers, proxies, gateways, tunnels, or caches), and memory used for TCP protocol control blocks can be saved in hosts.<br>b. HTTP requests and responses can be pipelined on a connection. Pipelining allows a client to make multiple requests without waiting for each response, allowing a single TCP connection to be used much more efficiently, with much lower elapsed time.<br>c. Network congestion is reduced by reducing the number of packets caused by TCP opens, and by allowing TCP sufficient time to determine the congestion state of the network.<br>d. Latency on subsequent requests is reduced since there is no time spent in TCP’s connection opening handshake.<br> e. HTTP can evolve more gracefully, since errors can be reported without the penalty of closing the TCP connection. Clients using     future versions of HTTP might optimistically try a new feature, but if communicating with an older server, retry with old   semantics after an error is reported.<br>RFC 2616（P47）还指出：单用户客户端与任何服务器或代理之间的连接数不应该超过2个。一个代理与其它服务器或代码之间应该使用超过2 * N的活跃并发连接。这是为了提高HTTP响应时间，避免拥塞（冗余的连接并不能代码执行性能的提升）。</p><h2 id="3、回到我们的问题（即如何判断消息内容-长度的大小？）"><a href="#3、回到我们的问题（即如何判断消息内容-长度的大小？）" class="headerlink" title="3、回到我们的问题（即如何判断消息内容/长度的大小？）"></a>3、回到我们的问题（即如何判断消息内容/长度的大小？）</h2><p>Keep-Alive模式，客户端如何判断请求所得到的响应数据已经接收完成（或者说如何知道服务器已经发生完了数据）？我们已经知道了，Keep-Alive模式发送玩数据HTTP服务器不会自动断开连接，所有不能再使用返回EOF（-1）来判断（当然你一定要这样使用也没有办法，可以想象那效率是何等的低）！下面我介绍两种来判断方法。</p><h3 id="3-1、使用消息首部字段Conent-Length"><a href="#3-1、使用消息首部字段Conent-Length" class="headerlink" title="3.1、使用消息首部字段Conent-Length"></a>3.1、使用消息首部字段Conent-Length</h3><p>故名思意，Conent-Length表示实体内容长度，客户端（服务器）可以根据这个值来判断数据是否接收完成。但是如果消息中没有Conent-Length，那该如何来判断呢？又在什么情况下会没有Conent-Length呢？请继续往下看……</p><h3 id="3-2、使用消息首部字段Transfer-Encoding"><a href="#3-2、使用消息首部字段Transfer-Encoding" class="headerlink" title="3.2、使用消息首部字段Transfer-Encoding"></a>3.2、使用消息首部字段Transfer-Encoding</h3><p>当客户端向服务器请求一个静态页面或者一张图片时，服务器可以很清楚的知道内容大小，然后通过Content-length消息首部字段告诉客户端需要接收多少数据。但是如果是动态页面等时，服务器是不可能预先知道内容大小，这时就可以使用Transfer-Encoding：chunk模式来传输数据了。即如果要一边产生数据，一边发给客户端，服务器就需要使用”Transfer-Encoding: chunked”这样的方式来代替Content-Length。<br>chunk编码将数据分成一块一块的发生。Chunked编码将使用若干个Chunk串连而成，由一个标明长度为0的chunk标示结束。每个Chunk分为头部和正文两部分，头部内容指定正文的字符总数（十六进制的数字）和数量单位（一般不写），正文部分就是指定长度的实际内容，两部分之间用回车换行(CRLF)隔开。在最后一个长度为0的Chunk中的内容是称为footer的内容，是一些附加的Header信息（通常可以直接忽略）。<br>Chunk编码的格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Chunked-Body = *chunk</div><div class="line">“0” CRLF</div><div class="line">footer</div><div class="line">CRLF</div><div class="line">chunk = chunk-size [ chunk-ext ] CRLF</div><div class="line">chunk-data CRLF</div><div class="line">hex-no-zero = &lt;HEX excluding “0”&gt;</div><div class="line">chunk-size = hex-no-zero *HEX</div><div class="line">chunk-ext = *( “;” chunk-ext-name [ “=” chunk-ext-value ] )</div><div class="line">chunk-ext-name = token</div><div class="line">chunk-ext-val = token | quoted-string</div><div class="line">chunk-data = chunk-size(OCTET)</div><div class="line">footer = *entity-header</div></pre></td></tr></table></figure></p><p>即Chunk编码由四部分组成：<br>1、0至多个chunk块，<br>2、“0” CRLF，<br>3、footer，<br>4、CRLF.而每个chunk块由：chunk-size、chunk-ext（可选）、CRLF、chunk-data、CRLF组成。</p><h2 id="4、消息长度的总结"><a href="#4、消息长度的总结" class="headerlink" title="4、消息长度的总结"></a>4、消息长度的总结</h2><p>其实，上面2中方法都可以归纳为是如何判断http消息的大小、消息的数量。RFC 2616对消息的长度总结如下：一个消息的transfer-length（传输长度）是指消息中的message-body（消息体）的长度。当应用了transfer-coding（传输编码），每个消息中的message-body（消息体）的长度（transfer-length）由以下几种情况决定（优先级由高到低）：</p><ul><li>任何不含有消息体的消息（如1XXX、204、304等响应消息和任何头(HEAD，首部)请求的响应消息），总是由一个空行（CLRF）结束。</li><li>如果出现了Transfer-Encoding头字段 并且值为非“identity”，那么transfer-length由“chunked” 传输编码定义，除非消息由于关闭连接而终止。</li><li>如果出现了Content-Length头字段，它的值表示entity-length（实体长度）和transfer-length（传输长度）。如果这两个长度的大小不一样（i.e.设置了Transfer-Encoding头字段），那么将不能发送Content-Length头字段。并且如果同时收到了Transfer-Encoding字段和Content-Length头字段，那么必须忽略Content-Length字段。</li><li>如果消息使用媒体类型“multipart/byteranges”，并且transfer-length 没有另外指定，那么这种自定界（self-delimiting）媒体类型定义transfer-length 。除非发送者知道接收者能够解析该类型，否则不能使用该类型。</li><li>由服务器关闭连接确定消息长度。（注意：关闭连接不能用于确定请求消息的结束，因为服务器不能再发响应消息给客户端了。）<br>为了兼容HTTP/1.0应用程序，HTTP/1.1的请求消息体中必须包含一个合法的Content-Length头字段，除非知道服务器兼容HTTP/1.1。一个请求包含消息体，并且Content-Length字段没有给定，如果不能判断消息的长度，服务器应该用用400 (bad request) 来响应；或者服务器坚持希望收到一个合法的Content-Length字段，用 411 (length required)来响应。<br>所有HTTP/1.1的接收者应用程序必须接受“chunked” transfer-coding (传输编码)，因此当不能事先知道消息的长度，允许使用这种机制来传输消息。消息不应该够同时包含 Content-Length头字段和non-identity transfer-coding。如果一个消息同时包含non-identity transfer-coding和Content-Length ，必须忽略Content-Length 。<br>5、HTTP头字段总结<br>最后我总结下HTTP协议的头部字段。</li></ul><p>1、 Accept：告诉WEB服务器自己接受什么介质类型，<em>/</em> 表示任何类型，type/* 表示该类型下的所有子类型，type/sub-type。</p><p>2、 Accept-Charset： 浏览器申明自己接收的字符集<br>Accept-Encoding： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate）<br>Accept-Language：浏览器申明自己接收的语言<br>语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等。</p><p>3、 Accept-Ranges：WEB服务器表明自己是否接受获取其某个实体的一部分（比如文件的一部分）的请求。bytes：表示接受，none：表示不接受。</p><p>4、 Age：当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了。</p><p>5、 Authorization：当客户端接收到来自WEB服务器的 WWW-Authenticate 响应时，用该头部来回应自己的身份验证信息给WEB服务器。</p><p>6、 Cache-Control：请求：no-cache（不要缓存的实体，要求现在从WEB服务器去取）<br>max-age：（只接受 Age 值小于 max-age 值，并且没有过期的对象）<br>max-stale：（可以接受过去的对象，但是过期时间必须小于 max-stale 值）<br>min-fresh：（接受其新鲜生命期大于其当前 Age 跟 min-fresh 值之和的缓存对象）<br>响应：public(可以用 Cached 内容回应任何用户)<br>private（只能用缓存内容回应先前请求该内容的那个用户）<br>no-cache（可以缓存，但是只有在跟WEB服务器验证了其有效后，才能返回给客户端）<br>max-age：（本响应包含的对象的过期时间）<br>ALL: no-store（不允许缓存）</p><p>7、 Connection：请求：close（告诉WEB服务器或者代理服务器，在完成本次请求的响应后，断开连接，不要等待本次连接的后续请求了）。<br>keepalive（告诉WEB服务器或者代理服务器，在完成本次请求的响应后，保持连接，等待本次连接的后续请求）。<br>响应：close（连接已经关闭）。<br>keepalive（连接保持着，在等待本次连接的后续请求）。<br>Keep-Alive：如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持连接多长时间（秒）。例如：Keep-Alive：300</p><p>8、 Content-Encoding：WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。例如：Content-Encoding：gzip</p><p>9、Content-Language：WEB 服务器告诉浏览器自己响应的对象的语言。</p><p>10、Content-Length： WEB 服务器告诉浏览器自己响应的对象的长度。例如：Content-Length: 26012</p><p>11、Content-Range： WEB 服务器表明该响应包含的部分对象为整个对象的哪个部分。例如：Content-Range: bytes 21010-47021/47022</p><p>12、Content-Type： WEB 服务器告诉浏览器自己响应的对象的类型。例如：Content-Type：application/xml</p><p>13、ETag：就是一个对象（比如URL）的标志值，就一个对象而言，比如一个 html 文件，如果被修改了，其 Etag 也会别修改，所以ETag 的作用跟 Last-Modified 的作用差不多，主要供 WEB 服务器判断一个对象是否改变了。比如前一次请求某个 html 文件时，获得了其 ETag，当这次又请求这个文件时，浏览器就会把先前获得的 ETag 值发送给WEB 服务器，然后 WEB 服务器会把这个 ETag 跟该文件的当前 ETag 进行对比，然后就知道这个文件有没有改变了。</p><p>14、 Expired：WEB服务器表明该实体将在什么时候过期，对于过期了的对象，只有在跟WEB服务器验证了其有效性后，才能用来响应客户请求。是 HTTP/1.0 的头部。例如：Expires：Sat, 23 May 2009<br>10:02:12 GMT</p><p>15、 Host：客户端指定自己想访问的WEB服务器的域名/IP 地址和端口号。例如：Host：rss.sina.com.cn</p><p>16、 If-Match：如果对象的 ETag 没有改变，其实也就意味著对象没有改变，才执行请求的动作。</p><p>17、 If-None-Match：如果对象的 ETag 改变了，其实也就意味著对象也改变了，才执行请求的动作。</p><p>18、 If-Modified-Since：如果请求的对象在该头部指定的时间之后修改了，才执行请求的动作（比如返回对象），否则返回代码304，告诉浏览器该对象没有修改。例如：If-Modified-Since：Thu, 10 Apr 2008 09:14:42 GMT</p><p>19、 If-Unmodified-Since：如果请求的对象在该头部指定的时间之后没修改过，才执行请求的动作（比如返回对象）。</p><p>20、 If-Range：浏览器告诉 WEB 服务器，如果我请求的对象没有改变，就把我缺少的部分给我，如果对象改变了，就把整个对象给我。浏览器通过发送请求对象的 ETag 或者 自己所知道的最后修改时间给 WEB 服务器，让其判断对象是否改变了。总是跟 Range 头部一起使用。</p><p>21、 Last-Modified：WEB 服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间等等。例如：Last-Modified：Tue, 06 May 2008 02:42:43 GMT</p><p>22、 Location：WEB 服务器告诉浏览器，试图访问的对象已经被移到别的位置了，到该头部指定的位置去取。例如：Location：<a href="http://i0.sinaimg.cn/dy/deco/2008/0528/sinahome_0803_ws_005_text_0.gif" target="_blank" rel="external">http://i0.sinaimg.cn/dy/deco/2008/0528/sinahome_0803_ws_005_text_0.gif</a></p><p>23、 Pramga：主要使用 Pramga: no-cache，相当于 Cache-Control： no-cache。例如：Pragma：no-cache</p><p>24、 Proxy-Authenticate： 代理服务器响应浏览器，要求其提供代理身份验证信息。Proxy-Authorization：浏览器响应代理服务器的身份验证请求，提供自己的身份信息。</p><p>25、 Range：浏览器（比如 Flashget 多线程下载时）告诉 WEB 服务器自己想取对象的哪部分。例如：Range: bytes=1173546-</p><p>26、 Referer：浏览器向 WEB 服务器表明自己是从哪个 网页/URL 获得/点击 当前请求中的网址/URL。例如：Referer：<a href="http://www.sina.com/" target="_blank" rel="external">http://www.sina.com/</a></p><p>27、 Server: WEB 服务器表明自己是什么软件及版本等信息。例如：Server：Apache/2.0.61 (Unix)28、 User-Agent: 浏览器表明自己的身份（是哪种浏览器）。例如：User-Agent：Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.8.1.14) Gecko/20080404 Firefox/2、0、0、14</p><p>29、 Transfer-Encoding: WEB 服务器表明自己对本响应消息体（不是消息体里面的对象）作了怎样的编码，比如是否分块（chunked）。例如：Transfer-Encoding: chunked</p><p>30、 Vary:web服务器用该头部的内容告诉Cache服务器，在什么条件下才能用本响应所返回的对象响应后续的请求。假如源WEB服务器在接到第一个请求消息时，其响应消息的头部为：Content-Encoding: gzip; Vary: Content-Encoding,那么 Cache 服务器会分析后续请求消息的头部，检查其 Accept-Encoding，是否跟先前响应的 Vary 头部值一致，即是否使用相同的内容编码方法，这样就可以防止 Cache 服务器用自己 Cache 里面压缩后的实体响应给不具备解压能力的浏览器。例如：Vary：Accept-Encoding</p><p>31、 Via： 列出从客户端到 OCS 或者相反方向的响应经过了哪些代理服务器，他们用什么协议（和版本）发送的请求。当客户端请求到达第一个代理服务器时，该服务器会在自己发出的请求里面添加 Via 头部，并填上自己的相关信息，当下一个代理服务器收到第一个代理服务器的请求时，会在自己发出的请求里面复制前一个代理服务器的请求的Via 头部，并把自己的相关信息加到后面，以此类推，当 OCS 收到最后一个代理服务器的请求时，检查 Via 头部，就知道该请求所经过的路由。例如：Via：1.0 236.D0707195.sina.com.cn:80 (squid/2.6.STABLE13)</p><p>===============================================================================<br>HTTP 请求消息头部实例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Host：rss.sina.com.cn</div><div class="line">User-Agent：Mozilla/5、0 (Windows; U; Windows NT 5、1; zh-CN; rv:1、8、1、14) Gecko/20080404 Firefox/2、0、0、14</div><div class="line">Accept：text/xml,application/xml,application/xhtml+xml,text/html;q=0、9,text/plain;q=0、8,image/png,*/*;q=0、5</div><div class="line">Accept-Language：zh-cn,zh;q=0、5</div><div class="line">Accept-Encoding：gzip,deflate</div><div class="line">Accept-Charset：gb2312,utf-8;q=0、7,*;q=0、7</div><div class="line">Keep-Alive：300</div><div class="line">Connection：keep-alive</div><div class="line">Cookie：userId=C5bYpXrimdmsiQmsBPnE1Vn8ZQmdWSm3WRlEB3vRwTnRtW &amp;lt;– Cookie</div><div class="line">If-Modified-Since：Sun, 01 Jun 2008 12:05:30 GMT</div><div class="line">Cache-Control：max-age=0</div><div class="line">HTTP 响应消息头部实例：</div><div class="line">Status：OK – 200 &amp;lt;– 响应状态码，表示 web 服务器处理的结果。</div><div class="line">Date：Sun, 01 Jun 2008 12:35:47 GMT</div><div class="line">Server：Apache/2、0、61 (Unix)</div><div class="line">Last-Modified：Sun, 01 Jun 2008 12:35:30 GMT</div><div class="line">Accept-Ranges：bytes</div><div class="line">Content-Length：18616</div><div class="line">Cache-Control：max-age=120</div><div class="line">Expires：Sun, 01 Jun 2008 12:37:47 GMT</div><div class="line">Content-Type：application/xml</div><div class="line">Age：2</div><div class="line">X-Cache：HIT from 236-41、D07071951、sina、com、cn &amp;lt;– 反向代理服务器使用的 HTTP 头部</div><div class="line">Via：1.0 236-41.D07071951.sina.com.cn:80 (squid/2.6.STABLE13)</div><div class="line">Connection：close</div></pre></td></tr></table></figure></p><p>本节摘自：<a href="http://ynhu33.blog.51cto.com/412835/408801" target="_blank" rel="external">http://ynhu33.blog.51cto.com/412835/408801</a></p>]]></content>
    
    <summary type="html">
    
      我们知道HTTP协议采用“请求-应答”模式，当使用普通模式，即非KeepAlive模式时，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接（HTTP协议为无连接的协议）；当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。
    
    </summary>
    
    
      <category term="http" scheme="http://loewenw.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>GIT和SVN的区别</title>
    <link href="http://loewenw.github.io/2017/11/10/20171110/"/>
    <id>http://loewenw.github.io/2017/11/10/20171110/</id>
    <published>2017-11-10T10:22:43.000Z</published>
    <updated>2017-12-20T05:57:31.008Z</updated>
    
    <content type="html"><![CDATA[<p>把第一条理解到位思想到位了做起来才会有的放矢，其他几条都是用的时候才能体会到<br>1) 最核心的区别Git是分布式的，而Svn不是分布的。能理解这点，上手会很容易，声明一点Git并不是目前唯一的分布式版本控制系统，还有比如Mercurial等，所以说它们差不许多。话说回来Git跟Svn一样有自己的集中式版本库和Server端，但Git更倾向于分布式开发，因为每一个开发人员的电脑上都有一个Local Repository,所以即使没有网络也一样可以Commit，查看历史版本记录，创建项 目分支等操作，等网络再次连接上Push到Server端。<br>从上面看GIt真的很棒，但是GIt adds Complexity,刚开始使用会有些疑惑，因为需要建两个Repositories(Local Repositories &amp; Remote Repositories),指令很多，除此之外你需要知道哪些指令在Local Repository，哪些指令在Remote Repository。<br>2)Git把内容按元数据方式存储，而SVN是按文件：因为,.git目录是处于你的机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签，分支，版本记录等。.git目录的体积大小跟.svn比较，你会发现它们差距很大。<br>3) Git没有一个全局版本号，而SVN有：目前为止这是跟SVN相比Git缺少的最大的一个特征。<br>4) Git的内容的完整性要优于SVN: GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。<br>5) Git下载下来后，在OffLine状态下可以看到所有的Log,SVN不可以。<br>6) 刚开始用时很狗血的一点，SVN必须先Update才能Commit,忘记了合并时就会出现一些错误，git还是比较少的出现这种情况。<br>7) 克隆一份全新的目录以同样拥有五个分支来说，SVN是同时复製5个版本的文件,也就是说重复五次同样的动作。而Git只是获取文件的每个版本的 元素，然后只载入主要的分支(master)在我的经验,克隆一个拥有将近一万个提交(commit),五个分支,每个分支有大约1500个文件的 SVN,耗了将近一个小时！而Git只用了区区的1分钟！</p><p>8) 版本库（repository):SVN只能有一个指定中央版本库。当这个中央版本库有问题时，所有工作成员都一起瘫痪直到版本库维修完毕或者新的版本库设立完成。而 Git可以有无限个版本库。或者，更正确的说法，每一个Git都是一个版本库，区别是它们是否拥有活跃目录（Git Working Tree）。如果主要版本库（例如：置於GitHub的版本库）发生了什麼事，工作成员仍然可以在自己的本地版本库（local repository）提交，等待主要版本库恢复即可。工作成员也可以提交到其他的版本库！<br>9)分支（Branch）在SVN，分支是一个完整的目录。且这个目录拥有完整的实际文件。如果工作成员想要开啟新的分支，那将会影响“全世界”！每个人都会拥有和你一样的分支。如果你的分支是用来进行破坏工作（安检测试），那将会像传染病一样,你改一个分支，还得让其他人重新切分支重新下载，十分狗血。而 Git，每个工作成员可以任意在自己的本地版本库开啟无限个分支。举例：当我想尝试破坏自己的程序（安检测试），并且想保留这些被修改的文件供日后使用， 我可以开一个分支，做我喜欢的事。完全不需担心妨碍其他工作成员。只要我不合并及提交到主要版本库，没有一个工作成员会被影响。等到我不需要这个分支时， 我只要把它从我的本地版本库删除即可。无痛无痒。<br>Git的分支名是可以使用不同名字的。例如：我的本地分支名为OK，而在主要版本库的名字其实是master。<br>最值得一提，我可以在Git的任意一个提交点（commit point）开启分支！（其中一个方法是使用gitk –all 可观察整个提交记录，然后在任意点开啟分支。）<br>10)提交（Commit）在SVN，当你提交你的完成品时，它将直接记录到中央版本库。当你发现你的完成品存在严重问题时，你已经无法阻止事情的发生了。如果网路中断，你根本没办法提交！而Git的提交完全属於本地版本库的活动。而你只需“推”（git push）到主要版本库即可。Git的“推”其实是在执行“同步”（Sync）。</p><h3 id="最后总结一下："><a href="#最后总结一下：" class="headerlink" title="最后总结一下："></a>最后总结一下：</h3><p>SVN的特点是简单，只是需要一个放代码的地方时用是OK的。<br>Git的特点版本控制可以不依赖网络做任何事情，对分支和合并有更好的支持(当然这是开发者最关心的地方)，不过想各位能更好使用它，需要花点时间尝试下。</p><p>原文链接 <a href="http://www.jianshu.com/p/bfec042349ca" target="_blank" rel="external">http://www.jianshu.com/p/bfec042349ca</a></p>]]></content>
    
    <summary type="html">
    
      SVN的特点是简单，只是需要一个放代码的地方时用是OK的。Git的特点版本控制可以不依赖网络做任何事情。
    
    </summary>
    
    
      <category term="other" scheme="http://loewenw.github.io/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>数据双向绑定以及Object.defineProperty函数</title>
    <link href="http://loewenw.github.io/2017/11/09/20171109/"/>
    <id>http://loewenw.github.io/2017/11/09/20171109/</id>
    <published>2017-11-09T03:36:04.000Z</published>
    <updated>2017-12-06T12:50:20.693Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于双向数据绑定"><a href="#关于双向数据绑定" class="headerlink" title="关于双向数据绑定"></a>关于双向数据绑定</h2><p>当我们在前端开发中采用MV*的模式时，M-model，指的是模型，也就是数据，V-view，指的是视图，也就是页面展现的部分。通常，我们需要编写代码，将从服务器获取的数据进行“渲染”，展现到视图上。每当数据有变更时，我们会再次进行渲染，从而更新视图，使得视图与数据保持一致。也就是：<br><img src="/img/Paste_Image1.png" alt=""></p><p>而另一方面，页面也会通过用户的交互，产生状态、数据的变化，这个时候，我们则编写代码，将视图对数据的更新同步到数据，以致于同步到后台服务器。也就是：<br><img src="/img/Paste_Image2.png" alt=""></p><p>不同的前端 MV* 框架对于这种 Model 和 View 间的数据同步有不同的处理。在 Backbone 中，Model 到 View 的数据传递，可以在 View 中监听 Model 的 change 事件，每当 Model 更新，View 中重新执行 render。而 View 到 Model 的数据传递，可以监听 View 对应的 DOM 元素的各种事件，在检测到 View 状态变更后，将变更的数据发送到 Model。相较于 Backbone，AngularJS 所代表的 MVVM 框架则更进一步，从框架层面支持这种数据同步机制，而且是双向数据绑定：<br><img src="/img/Paste_Image3.png" alt=""></p><p>不过在不同的 MVVM 框架中，实现双向数据绑定的技术有所不同。</p><p>AngularJS 采用“脏值检测”的方式，数据发生变更后，对于所有的数据和视图的绑定关系进行一次检测，识别是否有数据发生了改变，有变化进行处理，可能进一步引发其他数据的改变，所以这个过程可能会循环几次，一直到不再有数据变化发生后，将变更的数据发送到视图，更新页面展现。如果是手动对 ViewModel 的数据进行变更，为确保变更同步到视图，需要手动触发一次“脏值检测”。</p><p>VueJS 则使用 ES5 提供的 Object.defineProperty() 方法，监控对数据的操作，从而可以自动触发数据同步。并且，由于是在不同的数据上触发同步，可以精确的将变更发送给绑定的视图，而不是对所有的数据都执行一次检测。</p><h2 id="关于Object-defineProperty"><a href="#关于Object-defineProperty" class="headerlink" title="关于Object.defineProperty"></a>关于Object.defineProperty</h2><p>这个函数接受三个参数，一个参数是obj，表示要定义属性的对象,一个参数是prop，是要定义或者更改的属性名字，另外是descriptor,描述符，来定义属性的具体描述。<br>Object.defineProperty(obj, prop, descriptor)</p><p>下面的是实例代码，obj是一个没有属性的空对象，然后”key”是属性名，{}大括号里面定义了要给属性赋值的情况，value代表属性的值，proto代表继承属性的性质，这里面还有其他的选项。比如configurable,enumerable,writable等默认是false的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// using __proto__</div><div class="line">var obj = &#123;&#125;;</div><div class="line">Object.defineProperty(obj, <span class="string">'key'</span>, &#123;</div><div class="line">  __proto__: null, // no inherited properties</div><div class="line">  value: <span class="string">'static'</span>  // not enumerable</div><div class="line">                   // not configurable</div><div class="line">                   // not writable</div><div class="line">                   // as defaults</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>我们通过控制台的结果来感受一下writable为false的作用。我们发现，就算对”key”属性重新赋值了，它的属性仍然保持不变。</p><p><img src="/img/defineProperty01.png" alt=""></p><p>控制台结果</p><p>descriptors（描述符）分成两种，一种是data descriptors,另外一种是 accessor descriptors.两种的descriptors有两个必选项,configurable和enumerable</p><p>configurable<br>true if and only if the type of this property descriptor may be changed and if the property may be deleted from the corresponding object.Defaults to false<br>.</p><p>代表这个属性的descriptor也就是描述是可以更改的，这个熟悉也能从对象上面删除,默认false,也就是不能更改跟属性有关的任意值，如果我重新对这个属性进行定义的话，会提示出错,同时也不能删除。</p><p><img src="/img/configurable.png" alt=""></p><p>configurable</p><p>enumerable<br>true if and only if this property shows up during enumeration of the properties on the corresponding object.Defaults to false<br>.</p><p>代表这个属性能够通过for in或者Object.keys<br> 来遍历。默认为false</p><p><img src="/img/defineProperty03.png" alt=""></p><p>关于enumerable的属性</p><p>A data descriptor有两个可选项.</p><p>value<br>The value associated with the property. Can be any valid JavaScript value (number, object, function, etc).Defaults to undefined<br>.</p><p>这个选项为属性赋值，可以是任意的JavaScript值，默认为undefined</p><p>writable<br>true if and only if the value associated with the property may be changed with an assignment operator.Defaults to false<br>.</p><p>writable表示能不能够重写属性值，默认为false</p><p>accessor descriptor也有两个关键的属性。</p><p>get<br>A function which serves as a getter for the property, or undefined<br> if there is no getter. The function return will be used as the value of property.Defaults to undefined<br>.<br>set</p><p>定义了一个函数，作为属性的getter,如果没有getter就为undefined 默认为undefined</p><p>set<br>A function which serves as a setter for the property, or undefined<br> if there is no setter. The function will receive as only argument the new value being assigned to the property.Defaults to undefined<br>.</p><p>同get</p><p>这里面有一点是，可能会从原型链上面继承相应的属性，如果想避免这种情况，可以写get。所以可以用<strong>proto</strong>: null</p><p>下面是一个可爱的例子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">var o = &#123;&#125;; // Creates a new object 创造对象</div><div class="line"></div><div class="line">// Example of an object property added with defineProperty with a data property descriptor</div><div class="line">Object.defineProperty(o, <span class="string">'a'</span>, &#123;</div><div class="line">  value: 37,</div><div class="line">  writable: <span class="literal">true</span>,</div><div class="line">  enumerable: <span class="literal">true</span>,</div><div class="line">  configurable: <span class="literal">true</span></div><div class="line">&#125;);</div><div class="line">// <span class="string">'a'</span> property exists <span class="keyword">in</span> the o object and its value is 37 </div><div class="line"></div><div class="line">// Example of an object property added with defineProperty with an accessor property descriptor</div><div class="line">var bValue = 38;</div><div class="line">Object.defineProperty(o, <span class="string">'b'</span>, &#123;</div><div class="line">  get: <span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> bValue; &#125;,</div><div class="line">  <span class="built_in">set</span>: <span class="keyword">function</span>(newValue) &#123; bValue = newValue; &#125;,</div><div class="line">  enumerable: <span class="literal">true</span>,</div><div class="line">  configurable: <span class="literal">true</span></div><div class="line">&#125;);</div><div class="line">o.b; // 38</div><div class="line">// <span class="string">'b'</span> property exists <span class="keyword">in</span> the o object and its value is 38</div><div class="line">// The value of o.b is now always identical to bValue, unless o.b is redefined</div><div class="line"></div><div class="line">// You cannot try to mix both:</div><div class="line">Object.defineProperty(o, <span class="string">'conflict'</span>, &#123;</div><div class="line">  value: 0x9f91102,</div><div class="line">  get: <span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> 0xdeadbeef; &#125;</div><div class="line">&#125;);</div><div class="line">// throws a TypeError: value appears only <span class="keyword">in</span> data descriptors, get appears only <span class="keyword">in</span> accessor descriptors</div></pre></td></tr></table></figure><p><img src="/img/defineProperty04.png" alt=""></p><p>执行结果</p><p>第一段代表定义了一个data descriptor,第二段代表定义了accessor descriptor，通get定义了取值操作，第三段代码告诉我们这两种不能混用。</p><h3 id="视图和数据变化绑定"><a href="#视图和数据变化绑定" class="headerlink" title="视图和数据变化绑定"></a>视图和数据变化绑定</h3><p>而vue.js主要利用了accessor descriptors的set和get来更新视图，这里看到的这个例子挺好，是一个简单的绑定。<br>对于一个html页面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">    &lt;p&gt;你好，&lt;span id=<span class="string">'nickName'</span>&gt;&lt;/span&gt;&lt;/p&gt;</div><div class="line">    &lt;div id=<span class="string">"introduce"</span>&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure><p>设置一个数据的属性的getter和setter</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//视图控制器</div><div class="line">var userInfo = &#123;&#125;;</div><div class="line">Object.defineProperty(userInfo, <span class="string">"nickName"</span>, &#123;</div><div class="line">    get: <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">        <span class="built_in">return</span> document.getElementById(<span class="string">'nickName'</span>).innerHTML;</div><div class="line">    &#125;,</div><div class="line">    <span class="built_in">set</span>: <span class="keyword">function</span>(nick)&#123;</div><div class="line">        document.getElementById(<span class="string">'nickName'</span>).innerHTML = nick;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">Object.defineProperty(userInfo, <span class="string">"introduce"</span>, &#123;</div><div class="line">    get: <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">        <span class="built_in">return</span> document.getElementById(<span class="string">'introduce'</span>).innerHTML;</div><div class="line">    &#125;,</div><div class="line">    <span class="built_in">set</span>: <span class="keyword">function</span>(introduce)&#123;</div><div class="line">        document.getElementById(<span class="string">'introduce'</span>).innerHTML = introduce;</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>然后就能愉快地绑定数据交互了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">userInfo.nickName = <span class="string">"xxx"</span>;</div><div class="line">userInfo.introduce = <span class="string">"我是xxx，我来自云南，..."</span></div></pre></td></tr></table></figure><h3 id="vue-js的数据变动"><a href="#vue-js的数据变动" class="headerlink" title="vue.js的数据变动"></a>vue.js的数据变动</h3><p>但是，这个例子只是数据和dom节点的绑定，而vue.js更为复杂一点，它在网页dom和accessor之间会有两层，一层是Wacher，一层是Directive，比如以下代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a = &#123; b: 1 &#125;</div><div class="line">var vm = new Vue(&#123; </div><div class="line">  data: data</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>把一个普通对象（a={b:1}）传给 Vue 实例作为它的 data 选项，Vue.js 将遍历它的属性，用Object.defineProperty 将它们转为 getter/setter,如图绿色的部分所示。<br>每次用户更改data里的数据的时候，比如a.b =1，setter就会重新通知Watcher进行变动，Watcher再通知Directive对dom节点进行更改。<br><img src="/img/defineProperty05.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      不同的前端 MV* 框架对于这种 Model 和 View 间的数据同步有不同的处理。在 Backbone 中，Model 到 View 的数据传递，可以在 View 中监听 Model 的 change 事件，每当 Model 更新，View 中重新执行 render。而 View 到 Model 的数据传递，可以监听 View 对应的 DOM 元素的各种事件，在检测到 View 状态变更后，将变更的数据发送到 Model。
    
    </summary>
    
    
      <category term="js" scheme="http://loewenw.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>元素居中方法</title>
    <link href="http://loewenw.github.io/2017/11/08/20171108/"/>
    <id>http://loewenw.github.io/2017/11/08/20171108/</id>
    <published>2017-11-08T01:30:24.000Z</published>
    <updated>2017-12-06T12:50:02.446Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、使用text-align-center-居中"><a href="#一、使用text-align-center-居中" class="headerlink" title="一、使用text-align: center;居中"></a>一、使用text-align: center;居中</h2><p>对于行内元素或具有inline-block属性的元素居中，比如span、img等可以使用text-align: center;来实现。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/*css*/</div><div class="line">div&#123;</div><div class="line">    border:1px solid red;</div><div class="line">    text-align: center;</div><div class="line">    width: 200px;</div><div class="line">&#125;</div><div class="line">div span&#123;</div><div class="line">    width: 100px;</div><div class="line">    background: <span class="comment">#ddd;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;!--HTML--&gt;</div><div class="line">&lt;div&gt;</div><div class="line">    &lt;span&gt;我是span元素&lt;/span&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure><p>！<a href="/img/center11.png"></a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/*css*/</div><div class="line">div&#123;</div><div class="line">    border:1px solid red;</div><div class="line">    text-align: center;</div><div class="line">    width: 200px;</div><div class="line">&#125;</div><div class="line">div img&#123;</div><div class="line">    height: auto;</div><div class="line">    background: <span class="comment">#ddd;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;!--HTML--&gt;</div><div class="line">&lt;div&gt;</div><div class="line">    &lt;img src=<span class="string">"a.jpg"</span> alt=<span class="string">"马超"</span> width=<span class="string">"100"</span>&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure><p>！<a href="/img/center12.png"></a></p><h2 id="二、使用margin-auto；居中"><a href="#二、使用margin-auto；居中" class="headerlink" title="二、使用margin: auto；居中"></a>二、使用margin: auto；居中</h2><p>使用margin: auto；来居中是平时布局里面最常用的了，但是和第一种方法不同的是这种css属性作用于本身元素，且必须给元素设定了宽度和具有display：block；的块级元素。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/*css*/</div><div class="line">div&#123;</div><div class="line">    border:1px solid red;</div><div class="line">    width: 200px;</div><div class="line">&#125;</div><div class="line">div span&#123;</div><div class="line">    width: 150px;</div><div class="line">    background: <span class="comment">#ddd;</span></div><div class="line">    margin:0 auto;</div><div class="line">    display: block;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;!--HTML--&gt;</div><div class="line">&lt;div&gt;</div><div class="line">    &lt;span&gt;我是span元素&lt;/span&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure><p>！<a href="/img/center21.png"></a></p><h2 id="三、定位居中"><a href="#三、定位居中" class="headerlink" title="三、定位居中"></a>三、定位居中</h2><p>这种方法好处是行内元素和块级元素都适用,但是需要知道元素本身的宽度<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/*css*/</div><div class="line">div&#123;</div><div class="line">    border:1px solid red;</div><div class="line">    width: 200px;</div><div class="line">    height: 200px;</div><div class="line">    position: relative;</div><div class="line">&#125;</div><div class="line">div span&#123;</div><div class="line">    width: 150px;</div><div class="line">    height: 50px;</div><div class="line">    background: <span class="comment">#ddd;</span></div><div class="line">    position: absolute;</div><div class="line">    left: 25px;</div><div class="line">    top:75px;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;!--HTML--&gt;</div><div class="line">&lt;div&gt;</div><div class="line">    &lt;span&gt;我是span元素&lt;/span&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure><p>！<a href="/img/center31.png"></a></p><h2 id="四、margin：auto；和定位的组合使用"><a href="#四、margin：auto；和定位的组合使用" class="headerlink" title="四、margin：auto；和定位的组合使用"></a>四、margin：auto；和定位的组合使用</h2><p>这种方法好处是行内元素和块级元素都适用,但是需要知道元素本身的宽度。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/*css*/</div><div class="line">div&#123;</div><div class="line">    border:1px solid red;</div><div class="line">    width: 200px;</div><div class="line">    height: 200px;</div><div class="line">    position: relative;</div><div class="line">&#125;</div><div class="line">div span&#123;</div><div class="line">    width: 150px;</div><div class="line">    height: 50px;</div><div class="line">    background: <span class="comment">#ddd;</span></div><div class="line">    position: absolute;</div><div class="line">    margin:auto;</div><div class="line">    left: 0;</div><div class="line">    right: 0;</div><div class="line">    top:0;</div><div class="line">    bottom: 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;!--HTML--&gt;</div><div class="line">&lt;div&gt;</div><div class="line">    &lt;span&gt;我是span元素&lt;/span&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure><p>！<a href="/img/center41.png"></a></p><h2 id="五、负margin和定位的组合使用"><a href="#五、负margin和定位的组合使用" class="headerlink" title="五、负margin和定位的组合使用"></a>五、负margin和定位的组合使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/*css*/</div><div class="line">div&#123;</div><div class="line">    border:1px solid red;</div><div class="line">    width: 200px;</div><div class="line">    height: 200px;</div><div class="line">    position: relative;</div><div class="line">&#125;</div><div class="line">div span&#123;</div><div class="line">    width: 150px;</div><div class="line">    height: 50px;</div><div class="line">    background: <span class="comment">#ddd;</span></div><div class="line">    position: absolute;</div><div class="line">    left: 50%;</div><div class="line">    top:50%;</div><div class="line">    margin:-25px 0 0 -75px;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;!--HTML--&gt;</div><div class="line">&lt;div&gt;</div><div class="line">    &lt;span&gt;我是span元素&lt;/span&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure><p>！<a href="/img/center51.png"></a></p><h2 id="六、calc和定位的组合使用"><a href="#六、calc和定位的组合使用" class="headerlink" title="六、calc和定位的组合使用"></a>六、calc和定位的组合使用</h2><p>calc是英文单词calculate(计算)的缩写，是css3的一个新增的功能，你可以使用calc()给元素的border、margin、pading、font-size和width等属性设置动态值。<br>calc使元素居中的原理和负margin是一样的，calc 允许你基于当前的页面布局计算尺寸。在上面的简单计算中， 50% 是容器元素的中心点，但是如果只设置50%会使图片的左上角对齐div的中心位置。 我们需要把图片向左和向上各移动图片宽高的一半。计算公式为：<br>top: calc(50% - (40% / 2));<br>left: calc(50% - (40% / 2));<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/*css*/</div><div class="line">div&#123;</div><div class="line">    border:1px solid red;</div><div class="line">    width: 200px;</div><div class="line">    height: 200px;</div><div class="line">    position: relative;</div><div class="line">&#125;</div><div class="line">div span&#123;</div><div class="line">    width: 150px;</div><div class="line">    height: 50px;</div><div class="line">    background: <span class="comment">#ddd;</span></div><div class="line">    position: absolute;</div><div class="line">    top: calc(50% - (50px / 2));</div><div class="line">    left: calc(50% - (150px / 2)); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;!--HTML--&gt;</div><div class="line">&lt;div&gt;</div><div class="line">    &lt;span&gt;我是span元素&lt;/span&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure><p>！<a href="/img/center61.png"></a></p><h2 id="七、使用translate居中"><a href="#七、使用translate居中" class="headerlink" title="七、使用translate居中"></a>七、使用translate居中</h2><p>这种方法实现原理和第五种是一样的，就是用css3的属性translate来达到和负margin一样的作用。translate是transform的一个值，在这里作用是定义2D转换。但是在IE9以下不支持。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/*css*/</div><div class="line">div&#123;</div><div class="line">    border:1px solid red;</div><div class="line">    width: 200px;</div><div class="line">    height: 200px;</div><div class="line">    position: relative;</div><div class="line">&#125;</div><div class="line">div span&#123;</div><div class="line">    width: 150px;</div><div class="line">    height: 50px;</div><div class="line">    background: <span class="comment">#ddd;</span></div><div class="line">    position: absolute;</div><div class="line">    left: 50%;</div><div class="line">    top:50%;</div><div class="line">    transform: translate(-50%, -50%);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;!--HTML--&gt;</div><div class="line">&lt;div&gt;</div><div class="line">    &lt;span&gt;我是span元素&lt;/span&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure><p>！<a href="/img/center71.png"></a></p><h2 id="八、使用flex居中"><a href="#八、使用flex居中" class="headerlink" title="八、使用flex居中"></a>八、使用flex居中</h2><p>使用flex居中不需要知道元素本身宽高以及元素的属性。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/*css*/</div><div class="line">div&#123;</div><div class="line">    border:1px solid red;</div><div class="line">    width: 200px;</div><div class="line">    height: 200px;</div><div class="line">    display: flex;</div><div class="line">    justify-content: center;</div><div class="line">    align-items: center;</div><div class="line">&#125;</div><div class="line">div span&#123;</div><div class="line">    background: <span class="comment">#ddd;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;!--HTML--&gt;</div><div class="line">&lt;div&gt;</div><div class="line">    &lt;span&gt;我是span元素&lt;/span&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure><p>！<a href="/img/center81.png"></a></p><h2 id="九、使用table-cell居中"><a href="#九、使用table-cell居中" class="headerlink" title="九、使用table-cell居中"></a>九、使用table-cell居中</h2><p>使用 display: table-cell, 而不是使用table标签; 可以实现水平居中和垂直居中，但是这种方法需要添加额外的元素作为外部容器。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/*css*/</div><div class="line">.center-aligned&#123;</div><div class="line">    border:1px solid red;</div><div class="line">    width: 200px;</div><div class="line">    height: 200px;</div><div class="line">    display: table;</div><div class="line">&#125;</div><div class="line">.center-core&#123;</div><div class="line">    display: table-cell;</div><div class="line">    text-align: center;</div><div class="line">    vertical-align: middle;</div><div class="line">&#125;</div><div class="line">span&#123;</div><div class="line">    background: <span class="comment">#ddd;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;!--HTML--&gt;</div><div class="line">&lt;div class=<span class="string">"center-aligned"</span>&gt;</div><div class="line">    &lt;div class=<span class="string">"center-core"</span>&gt;</div><div class="line">        &lt;span&gt;我是span元素&lt;/span&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure><p>！<a href="/img/center91.png"></a></p>]]></content>
    
    <summary type="html">
    
      用css实现元素居中方法。
    
    </summary>
    
    
      <category term="CSS" scheme="http://loewenw.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>BFC</title>
    <link href="http://loewenw.github.io/2017/11/07/20171107BFC/"/>
    <id>http://loewenw.github.io/2017/11/07/20171107BFC/</id>
    <published>2017-11-07T11:40:24.000Z</published>
    <updated>2017-12-20T06:00:28.743Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、BFC是什么？"><a href="#一、BFC是什么？" class="headerlink" title="一、BFC是什么？"></a>一、BFC是什么？</h2><p>在解释 BFC 是什么之前，需要先介绍 Box、Formatting Context的概念。<br>Box: CSS布局的基本单位<br>Box 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。让我们看看有哪些盒子：<br>block-level box:display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context；<br>inline-level box:display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context；<br>run-in box: css3 中才有，这儿先不讲了。</p><h3 id="Formatting-context"><a href="#Formatting-context" class="headerlink" title="Formatting context"></a>Formatting context</h3><p>Formatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block formatting context (简称BFC)和 Inline formatting context (简称IFC)。<br>CSS2.1 中只有 BFC 和 IFC, CSS3 中还增加了 GFC 和 FFC。</p><h3 id="BFC-定义"><a href="#BFC-定义" class="headerlink" title="BFC 定义"></a>BFC 定义</h3><p>BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。</p><h4 id="BFC布局规则："><a href="#BFC布局规则：" class="headerlink" title="BFC布局规则："></a>BFC布局规则：</h4><ol><li>内部的Box会在垂直方向，一个接一个地放置。</li><li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li><li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li><li>BFC的区域不会与float box重叠。</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li><li>计算BFC的高度时，浮动元素也参与计算</li></ol><h2 id="二、哪些元素会生成BFC"><a href="#二、哪些元素会生成BFC" class="headerlink" title="二、哪些元素会生成BFC?"></a>二、哪些元素会生成BFC?</h2><ol><li>根元素</li><li>float属性不为none</li><li>position为absolute或fixed</li><li>display为inline-block, table-cell, table-caption, flex, inline-flex</li><li>overflow不为visible</li></ol><h2 id="三、BFC的作用及原理"><a href="#三、BFC的作用及原理" class="headerlink" title="三、BFC的作用及原理"></a>三、BFC的作用及原理</h2><h4 id="1-自适应两栏布局"><a href="#1-自适应两栏布局" class="headerlink" title="1. 自适应两栏布局"></a>1. 自适应两栏布局</h4><p>代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;style&gt;</div><div class="line"> body &#123;</div><div class="line"> width: 300px;</div><div class="line"> position: relative;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> .aside &#123;</div><div class="line"> width: 100px;</div><div class="line"> height: 150px;</div><div class="line"> <span class="built_in">float</span>: left;</div><div class="line"> background: <span class="comment">#f66;</span></div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> .main &#123;</div><div class="line"> height: 200px;</div><div class="line"> background: <span class="comment">#fcc;</span></div><div class="line"> &#125;</div><div class="line">&lt;/style&gt;</div><div class="line">&lt;body&gt;</div><div class="line"> &lt;div class=<span class="string">"aside"</span>&gt;&lt;/div&gt;</div><div class="line"> &lt;div class=<span class="string">"main"</span>&gt;&lt;/div&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure></p><p>页面：<br><img src="/img/bfc01.png" alt=""></p><p>根据BFC布局规则第3条：<br>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。<br>因此，虽然存在浮动的元素aslide，但main的左边依然会与包含块的左边相接触。<br>根据BFC布局规则第四条：<br>BFC的区域不会与float box重叠。<br>我们可以通过通过触发main生成BFC， 来实现自适应两栏布局。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.main &#123;</div><div class="line"> overflow: hidden;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当触发main生成BFC后，这个新的BFC不会与浮动的aside重叠。因此会根据包含块的宽度，和aside的宽度，自动变窄。效果如下：<br><img src="/img/bfc02.png" alt=""></p><h4 id="2-清除内部浮动"><a href="#2-清除内部浮动" class="headerlink" title="2. 清除内部浮动"></a>2. 清除内部浮动</h4><p>代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;style&gt;</div><div class="line"> .par &#123;</div><div class="line"> border: 5px solid <span class="comment">#fcc;</span></div><div class="line"> width: 300px;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> .child &#123;</div><div class="line"> border: 5px solid <span class="comment">#f66;</span></div><div class="line"> width:100px;</div><div class="line"> height: 100px;</div><div class="line"> <span class="built_in">float</span>: left;</div><div class="line"> &#125;</div><div class="line">&lt;/style&gt;</div><div class="line">&lt;body&gt;</div><div class="line"> &lt;div class=<span class="string">"par"</span>&gt;</div><div class="line"> &lt;div class=<span class="string">"child"</span>&gt;&lt;/div&gt;</div><div class="line"> &lt;div class=<span class="string">"child"</span>&gt;&lt;/div&gt;</div><div class="line"> &lt;/div&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure></p><p>页面：<br><img src="/img/bfc03.png" alt=""></p><p>根据BFC布局规则第六条：<br>计算BFC的高度时，浮动元素也参与计算<br>为达到清除内部浮动，我们可以触发par生成BFC，那么par在计算高度时，par内部的浮动元素child也会参与计算。<br>代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.par &#123;</div><div class="line"> overflow: hidden;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>效果如下：<br><img src="/img/bfc04.png" alt=""></p><h4 id="3-防止垂直-margin-重叠"><a href="#3-防止垂直-margin-重叠" class="headerlink" title="3. 防止垂直 margin 重叠"></a>3. 防止垂直 margin 重叠</h4><p>代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;style&gt;</div><div class="line"> p &#123;</div><div class="line"> color: <span class="comment">#f55;</span></div><div class="line"> background: <span class="comment">#fcc;</span></div><div class="line"> width: 200px;</div><div class="line"> line-height: 100px;</div><div class="line"> text-align:center;</div><div class="line"> margin: 100px;</div><div class="line"> &#125;</div><div class="line">&lt;/style&gt;</div><div class="line">&lt;body&gt;</div><div class="line"> &lt;p&gt;Haha&lt;/p&gt;</div><div class="line"> &lt;p&gt;Hehe&lt;/p&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure></p><p>页面：<br><img src="/img/bfc05.png" alt=""></p><p>两个p之间的距离为100px，发送了margin重叠。<br>根据BFC布局规则第二条：<br>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠<br>我们可以在p外面包裹一层容器，并触发该容器生成一个BFC。那么两个P便不属于同一个BFC，就不会发生margin重叠了。<br>代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;style&gt;</div><div class="line"> .wrap &#123;</div><div class="line"> overflow: hidden;</div><div class="line"> &#125;</div><div class="line"> p &#123;</div><div class="line"> color: <span class="comment">#f55;</span></div><div class="line"> background: <span class="comment">#fcc;</span></div><div class="line"> width: 200px;</div><div class="line"> line-height: 100px;</div><div class="line"> text-align:center;</div><div class="line"> margin: 100px;</div><div class="line"> &#125;</div><div class="line">&lt;/style&gt;</div><div class="line">&lt;body&gt;</div><div class="line"> &lt;p&gt;Haha&lt;/p&gt;</div><div class="line"> &lt;div class=<span class="string">"wrap"</span>&gt;</div><div class="line"> &lt;p&gt;Hehe&lt;/p&gt;</div><div class="line"> &lt;/div&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure></p><p>效果如下:<br><img src="/img/bfc06.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实以上的几个例子都体现了BFC布局规则第五条：<br>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。<br>因为BFC内部的元素和外部的元素绝对不会互相影响，因此， 当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理</p><p>原文来自：<a href="http://blog.melonhuang.gitpress.org/~docs/css/1formattingContext.md" target="_blank" rel="external">前端文摘：BFC 神奇背后的原理 via Melon Space</a><br>编译来源：<a href="http://www.cnblogs.com/lhb25/" target="_blank" rel="external">梦想天空 ◆ 关注前端开发技术 ◆ 分享网页设计资源</a></p>]]></content>
    
    <summary type="html">
    
      BFC(Block formatting context)直译为&quot;块级格式化上下文&quot;。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。
    
    </summary>
    
    
      <category term="CSS" scheme="http://loewenw.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Debounce 和 Throttle 的原理</title>
    <link href="http://loewenw.github.io/2017/11/05/20171105debounce/"/>
    <id>http://loewenw.github.io/2017/11/05/20171105debounce/</id>
    <published>2017-11-05T02:20:47.000Z</published>
    <updated>2017-12-06T03:06:58.278Z</updated>
    
    <content type="html"><![CDATA[<p>在处理诸如 resize、scroll、mousemove 和 keydown/keyup/keypress 等事件的时候，通常我们不希望这些事件太过频繁地触发，尤其是监听程序中涉及到大量的计算或者有非常耗费资源的操作。</p><p>有多频繁呢？以 mousemove 为例，根据 DOM Level 3 的规定，「如果鼠标连续移动，那么浏览器就应该触发多个连续的 mousemove 事件」，这意味着浏览器会在其内部计时器允许的情况下，根据用户移动鼠标的速度来触发 mousemove 事件。（当然了，如果移动鼠标的速度足够快，比如“刷”一下扫过去，浏览器是不会触发这个事件的）。resize、scroll 和 key* 等事件与此类似。</p><p>可以参看这个 Demo 体会下。</p><h2 id="Debounce"><a href="#Debounce" class="headerlink" title="Debounce"></a>Debounce</h2><p>DOM 事件里的 debounce 概念其实是从机械开关和继电器的“去弹跳”（debounce）衍生 出来的，基本思路就是把多个信号合并为一个信号。这篇文章 解释得非常清楚，感兴趣的可以一读。</p><p>在 JavaScript 中，debounce 函数所做的事情就是，强制一个函数在某个连续时间段内只执行一次，哪怕它本来会被调用多次。我们希望在用户停止某个操作一段时间之后才执行相应的监听函数，而不是在用户操作的过程当中，浏览器触发多少次事件，就执行多少次监听函数。</p><p>比如，在某个 3s 的时间段内连续地移动了鼠标，浏览器可能会触发几十（甚至几百）个 mousemove 事件，不使用 debounce 的话，监听函数就要执行这么多次；如果对监听函数使用 100ms 的“去弹跳”，那么浏览器只会执行一次这个监听函数，而且是在第 3.1s 的时候执行的。</p><p>现在，我们就来实现一个 debounce 函数。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>我们这个 debounce 函数接收两个参数，第一个是要“去弹跳”的回调函数 fn，第二个是延迟的时间 delay。</p><p>实际上，大部分的完整 debounce 实现还有第三个参数 immediate ，表明回调函数是在一个时间区间的最开始执行（immediate 为 true）还是最后执行（immediate 为 false），比如 underscore 的 _.debounce。本文不考虑这个参数，只考虑最后执行的情况，感兴趣的可以自行研究。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">*</div><div class="line">* @param fn &#123;Function&#125;   实际要执行的函数</div><div class="line">* @param delay &#123;Number&#125;  延迟时间，也就是阈值，单位是毫秒（ms）</div><div class="line">*</div><div class="line">* @<span class="built_in">return</span> &#123;Function&#125;     返回一个“去弹跳”了的函数</div><div class="line">*/</div><div class="line"><span class="keyword">function</span> debounce(fn, delay) &#123;</div><div class="line"></div><div class="line">  // 定时器，用来 setTimeout</div><div class="line">  var timer</div><div class="line"></div><div class="line">  // 返回一个函数，这个函数会在一个时间区间结束后的 delay 毫秒时执行 fn 函数</div><div class="line">  <span class="built_in">return</span> <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line"></div><div class="line">    // 保存函数调用时的上下文和参数，传递给 fn</div><div class="line">    var context = this</div><div class="line">    var args = arguments</div><div class="line"></div><div class="line">    // 每次这个返回的函数被调用，就清除定时器，以保证不执行 fn</div><div class="line">    clearTimeout(timer)</div><div class="line"></div><div class="line">    // 当返回的函数被最后一次调用后（也就是用户停止了某个连续的操作），</div><div class="line">    // 再过 delay 毫秒就执行 fn</div><div class="line">    timer = setTimeout(<span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">      fn.apply(context, args)</div><div class="line">    &#125;, delay)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其实思路很简单，debounce 返回了一个闭包，这个闭包依然会被连续频繁地调用，但是在闭包内部，却限制了原始函数 fn 的执行，强制 fn 只在连续操作停止后只执行一次。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">debounce 的使用方式如下：</div><div class="line"></div><div class="line">$(document).on(<span class="string">'mouvemove'</span>, debounce(<span class="keyword">function</span>(e) &#123;</div><div class="line">// 代码</div><div class="line">&#125;, 250))</div></pre></td></tr></table></figure></p><h3 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h3><p>还是以 mousemove 为例，为其绑定一个“去弹跳”的监听器，效果是怎样的？请看这个 Demo。<br>再来考虑另外一个场景：根据用户的输入实时向服务器发 ajax 请求获取数据。我们知道，浏览器触发 key<em> 事件也是非常快的，即便是正常人的正常打字速度，key</em> 事件被触发的频率也是很高的。以这种频率发送请求，一是我们并没有拿到用户的完整输入发送给服务器，二是这种频繁的无用请求实在没有必要。<br>更合理的处理方式是，在用户“停止”输入一小段时间以后，再发送请求。那么 debounce 就派上用场了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'input'</span>).on(<span class="string">'keyup'</span>, debounce(<span class="keyword">function</span>(e) &#123;</div><div class="line">// 发送 ajax 请求</div><div class="line">&#125;, 300))</div></pre></td></tr></table></figure><p>可以查看这个 Demo 看看效果。</p><p>##Throttle</p><p>throttle 的概念理解起来更容易，就是固定函数执行的速率，即所谓的“节流”。正常情况下，mousemove 的监听函数可能会每 20ms（假设）执行一次，如果设置 200ms 的“节流”，那么它就会每 200ms 执行一次。比如在 1s 的时间段内，正常的监听函数可能会执行 50（1000/20） 次，“节流” 200ms 后则会执行 5（1000/200） 次。<br>我们先来看 Demo。可以看到，不管鼠标移动的速度是慢是快，“节流”后的监听函数都会“匀速”地每 250ms 执行一次。</p><p>###实现</p><p>与 debounce 类似，我们这个 throttle 也接收两个参数，一个实际要执行的函数 fn，一个执行间隔阈值 threshhold。</p><p>同样的，throttle 的更完整实现可以参看 underscore 的 _.throttle。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">*</div><div class="line">* @param fn &#123;Function&#125;   实际要执行的函数</div><div class="line">* @param delay &#123;Number&#125;  执行间隔，单位是毫秒（ms）</div><div class="line">*</div><div class="line">* @<span class="built_in">return</span> &#123;Function&#125;     返回一个“节流”函数</div><div class="line">*/</div><div class="line"><span class="keyword">function</span> throttle(fn, threshhold) &#123;</div><div class="line"></div><div class="line">  // 记录上次执行的时间</div><div class="line">  var last</div><div class="line"></div><div class="line">  // 定时器</div><div class="line">  var timer</div><div class="line"></div><div class="line">  // 默认间隔为 250ms</div><div class="line">  threshhold || (threshhold = 250)</div><div class="line"></div><div class="line">  // 返回的函数，每过 threshhold 毫秒就执行一次 fn 函数</div><div class="line">  <span class="built_in">return</span> <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line"></div><div class="line">    // 保存函数调用时的上下文和参数，传递给 fn</div><div class="line">    var context = this</div><div class="line">    var args = arguments</div><div class="line"></div><div class="line">    var now = +new Date()</div><div class="line"></div><div class="line">    // 如果距离上次执行 fn 函数的时间小于 threshhold，那么就放弃</div><div class="line">    // 执行 fn，并重新计时</div><div class="line">    <span class="keyword">if</span> (last &amp;&amp; now &lt; last + threshhold) &#123;</div><div class="line">      clearTimeout(timer)</div><div class="line"></div><div class="line">      // 保证在当前时间区间结束后，再执行一次 fn</div><div class="line">      timer = setTimeout(<span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">        last = now</div><div class="line">        fn.apply(context, args)</div><div class="line">      &#125;, threshhold)</div><div class="line"></div><div class="line">    // 在时间区间的最开始和到达指定间隔的时候执行一次 fn</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      last = now</div><div class="line">      fn.apply(context, args)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>原理也不复杂，相比 debounce，无非是多了一个时间间隔的判断，其他的逻辑基本一致。throttle 的使用方式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(document).on(<span class="string">'mouvemove'</span>, throttle(<span class="keyword">function</span>(e) &#123;</div><div class="line">// 代码</div><div class="line">&#125;, 250))</div></pre></td></tr></table></figure></p><h3 id="用例-1"><a href="#用例-1" class="headerlink" title="用例"></a>用例</h3><p>throttle 常用的场景是限制 resize 和 scroll 的触发频率。以 scroll 为例，查看这个 Demo 感受下。</p><h3 id="可视化解释"><a href="#可视化解释" class="headerlink" title="可视化解释"></a>可视化解释</h3><p>如果还是不能完全体会 debounce 和 throttle 的差异，可以到 这个页面 看一下两者可视化的比较。</p><p><img src="/img/debounce-vs-throttle-v1.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>debounce 强制函数在某段时间内只执行一次，throttle 强制函数以固定的速率执行。在处理一些高频率触发的 DOM 事件的时候，它们都能极大提高用户体验。</p><p>文章来源：<a href="http://blog.csdn.net/redtopic/article/details/69396722" target="_blank" rel="external">Debounce 和 Throttle 的原理及实现</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在处理诸如 resize、scroll、mousemove 和 keydown/keyup/keypress 等事件的时候，通常我们不希望这些事件太过频繁地触发，尤其是监听程序中涉及到大量的计算或者有非常耗费资源的操作。&lt;/p&gt;
&lt;p&gt;有多频繁呢？以 mousemove 为
      
    
    </summary>
    
    
      <category term="js" scheme="http://loewenw.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://loewenw.github.io/2017/11/04/hello-world/"/>
    <id>http://loewenw.github.io/2017/11/04/hello-world/</id>
    <published>2017-11-04T09:26:30.000Z</published>
    <updated>2017-12-06T03:26:50.312Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      Welcome to loewenw! This is your very first post. Check  for more info. If you get any problems when using Hexo
    
    </summary>
    
    
      <category term="test" scheme="http://loewenw.github.io/tags/test/"/>
    
  </entry>
  
</feed>
